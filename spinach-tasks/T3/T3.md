# spinach的题面里面的《退役不学文化课OIer竟然能考上985?我的~随机化志愿填报算法果然写得有问题》是什么垃圾轻小说标题

## background
> 这是个原题,很抱歉,由于个人水平不足以出三个覆盖不同考点,难度适宜,正确性经过严谨检验,数据构造合理的的原创题.

## statement

给定序列$(a_1,a_2\dots a_n)$设$b_i=\frac{a_i}{i}$  
初始时,$a_1=a_2\dots a_n=0$
进行$m$次操作.  
1. 给出$(x,y)$做$a_x=y$  
2. 查询$b$的最长严格上升子序列长度.   


## I/O + restriction

### 分数计算与数据范围

10组数据,独立计算分数.  
$1\leq x\leq n$,$1\leq y\leq 10^9$,$1\leq n,m\leq 10^5$  

数据有一定梯度,但是没有特性...

### 输入输出格式
输入  
第一行$n,m$两个正整数. 之后$m$行,每行两个整数$x,y$表示一个操作.  

输出  
$m$行,表示每次操作后的LIS长度.

```
3 4
2 4
3 6
1 1000000000
1 1
------------------
1
1
1
2
```


## solution

<!--分块暴力的经典题,是BZOJ2957楼房重建.-->

<!--先考虑暴力  -->
<!--修改直接做,然后遍历一下$b[1..n]$更新答案.  -->

<!--我们考虑修改操作$upd(x,y)$生效后答案的变化.   -->
<!--- 如果$slope(x)$很大,$i\lt x$部分的上升子序列可以全都保留,那么考虑后面的部分的上升子序列 **扔掉一点前缀** 使得能够和$(x,y)$拼接上去.-->
<!--- 如果$slope(x)$变小,那么后面会有一部分之前没有贡献而现在有贡献(当然这个部分可能是空的).  -->

<!--仔细思考一下,发现这并不可做...至少很难简单实现.这就让我们看到.这个问题需要维护的数据是**无法高效合并**的,这启发我们使用分块,让影响局部化,等到查询的时候再来处理以平衡复杂度.  -->

<!--做法也就比较容易想到了.对序列分块,维护**只考虑块内元素的答案(一个单调增子序列)**,修改操作直接暴力重构,这部分复杂度为$O(S)$,其中$S$为块大小.  -->
<!--查询时,我们需要考虑整块前的所有元素对块的影响,显然我们要记录之前的最大斜率..那么拼接操作就是需要在这个块的上升子序列中,找到一个可以和之前的最大斜率拼接的位置,保留之后的部分.  -->
<!--这部分使用一个二分即可,复杂度为$O(\frac{n}{S}\times log\,S)$  -->

<!--这里遇到了修改与查询的复杂度不平衡(当然常数也不平衡...),我们可以考虑上个均值不等式看看块大小怎么取最优.  -->

<!--我们不如先假设序列大小和查询次数是同阶的(这里只是找最优的渐进理论复杂度,实际上还要考虑众多因素的影响...比较简单的方法是直接造随机数据测试出较好的块大小..).  -->
<!--总复杂度为$O(n\cdot (S+\frac{n}{S}\cdot log\,S))\geq O(n\sqrt{n\cdot log\,S})$...发现不好做,于是把$log\,S$近似为$log\,n$,这个影响是非常小的...当然为了严谨一点你应该求个导仔细分析一下最小值和最优的$S$.  -->
<!--$O(n\cdot (S+\frac{n}{S}\cdot log\,n))\geq O(n\sqrt{n\cdot log\,n})$.当$S=\frac{n}{S}log\,n$时最优,即$S=\sqrt{nlogn}$  -->




